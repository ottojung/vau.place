<!DOCTYPE html>
<html lang="en">
<head>
  <title> Vau's blog </title>
  <meta charset="UTF-8">
  <meta name="robots" content="noindex"> <!-- prevent robots from indexing -->
  <link rel="stylesheet" href="./style/main.css">
  <meta property='og:image' content='./assets/dog.jpg'>
  <meta property='og:description' content="Programming blog">
  <meta property='og:type' content='website'>
</head>
<body>

  <h3> Some Haskell history </h3>

  <p>
  Haskell is one of the most influential languages and among the most discussed ones.
  This post is dedicated to the history, and the funny bits, of Haskell.
  We'll uncover some lesser-known facts along the way,
  and may even debunk some common misconceptions about the language.

  </p>
  <p>

  Despite its modern appearance, Haskell is actualy pretty old.
  The starting point is 1987,
  the year when a small group of PL researchers met in Portland to discuss the state of the field.
  Quickly they converged to the common realization that there were too many functional programming languages.
  The solution, as always, is to come up with a new language
  that would somehow be simple and have all the features that a functional programmer could want.

  </p><p>

  As soon as the design process began, an effort to find new and exciting ways to implement it had started.
  Since Haskell is lazy, existing implementations, at the time, were based on graph reductions,
  and were inspired by a great work on SKI combinators -- the topic for which Haskell Curry is most known for.
  And the solution that Haskell adopted, and uses to this day,
  was the Spineless Tagless G-Machine,
  a virtual machine (as in JVM) quite similar to those that already existed -- the "G" stood for "Graph", after all.

  </p><p>

  Since the infamous lecture of John Backus in 1978,
  it was clear to all that procedural programming is about dead,
  and everyone was looking in the direction of functional.
  So on the desing side, apart from the mentioned laziness,
  it was set that Haskell must be functional.
  But how functional it really was?
  To understand, note that the word has changed its meaning over time.
  The canonical example of a functional language then
  was APL, which John Backus used in his lecture.
  As for Haskell, it was really not much more functional than many of the existing Lisps.

  </p><p>

  Laziness was another thing, that although differentiated Haskell from Lisp,
  still wasn't its unique feature,
  but it was the thing that forced the language to be pure.
  And in the beginning, purity was nothing but an obstacle,
  something that the creators were themselves embarrassed about.

  </p><p>

  The design process continued in a context of a committee.
  To quote the authors:
  <br><br><div class="quotebox">
    Haskell is a language designed by committee, and conventional
    wisdom would say that a committee language will be full of
    warts and awkward compromises. In a memorable letter
    to the Haskell committee, Tony Hoare wistfully remarked that
    Haskell was "probably doomed to succeed".
  </div><br>
  And then the unofficial motto of Haskell became "Avoid success at all cost".

  </p><p>

  But anyways, the design was complete in three years, and resulted in a report.
  This is what authors say about the date:
  <br><br><div class="quotebox">
    <code>></code> Was Haskell a joke? <br>
    The first edition of the Haskell Report was published on April 1, 1990.
    It was mostly an accident that it appeared on April Foolâ€™s
    Day -- a date had to be chosen, and the release was close enough to
    April 1 to justify using that date.</code></pre>
  </div><br>

  </p><p>

  On the technical side,
  the most distinctive and valuable contribution of Haskell were type classes,
  as judged by its creators.
  Type classes is a particular way to add polymorphism to functions,
  similar to interfaces and generics.

  </p><p>

  And as a solution to the purity problem, there were monads.
  Notably, the original solution, described in the report,
  was based on continuations (completely differrent idea),
  and monadic I/O was introduced only in 1992.
  Now monads is the thing Haskell is known for,
  and as authors themselves write:
  <br><br><div class="quotebox">
    In retrospect, therefore, perhaps the biggest single
    benefit of laziness is not laziness per se, but rather that laziness
    kept us pure, and thereby motivated a great deal of productive work
    on monads and encapsulated state.
  </div><br>

  </p><p>

  But long time has passed since, what is Haskell today?
  First and most unfortunate, Haskell aged.
  And as defined by the Linus' law -- when programs age,
  they get bigger (more bloated), and no popular language
  has avoided this fate, not even Haskell.
  To be fair, it was already a big language in the beginning,
  but now it's simply Huge,
  with almost a hundred "extensions" available to enable specific features of the language.

  </p><p>

  Another consequence of aging, is that some desing choices become obsolete.
  This is what, arguably, happened to monads, which were originally introduced to tackle
  the side-effects problem, and now are gradually being replaced by the new hot thing --
  the algebraic effect handlers.

  </p><p>

  Personally I can say that one of the most overlooked strong sides of Haskell is its meme-generating potential.
  Over the years, the Haskell community has come up with amusing pearls like
  "Monad is just a monoid in the category of endofunctors", "Monads are burritos", "Avoid success at all costs",
  and "Haskell will make you a better programmer".

  </p><p>

  For a more accurate history of haskell, there is a great write up
  from the founding fathers:
  <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/history.pdf?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Fsimonpj%2Fpapers%2Fhistory-of-haskell%2Fhistory.pdf">
    link
  </a>.
  All the quotes are from this paper.

  <code><br><br><a href="./../index.html"><span class="keyword">return</span> home</a></code>

</body>
</html>
